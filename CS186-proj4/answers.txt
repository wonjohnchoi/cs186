Describe any design decisions you made, including your deadlock detection policy, locking granularity, etc.
1) We implemented page-level locking. Instead of using java lock class (reentrantreadwritelock), we decided to create a private class Locks that manages which transaction holds locks for which pages. Inside Locks class, there are three HashMaps to manage this: HashMap of shared lock (maps PageId to the list of Tids holding locks), HashMap of exclusive lock (maps PageId to tid), and HashMap of list of locks held by my transaction. Lock acquiring method returns true when the transaction acquired the lock, otherwise false. There's a while loop with acquire() in getPage(), so that the page can be returned only after the transaction acquired the lock. Locks are released only after the transaction commits (strict 2PL).
For deadlock detection, we use timeout-based method. If a transaction fails to get its lock for over a fixed time period (we use 2000ms because this seems to do well in tests), we assume that the transaction is failing due to a deadlock. To resolve the deadlock, the transaction aborts with TransactionAbortedException, releasing all locks held by the transaction, hence giving other transactions a chance to continue with their tasks.

In part 2.3, we ask you to implement NO STEAL/FORCE buffer management policy and assume that the system won't crash while running transactionComplete. Why does NO STEAL/FORCE and no crashes while processing transactionComplete makes your job easier. In other words, what's complicated about implementing STEAL/NO FORCE buffer management policy and what measures do we need to take if our system could crash while running transactionComplete.
2) If we implemented STEAL/NO FORCE policy, it is complicated to enforce atomicity (STEAL) and durability (NO FORCE). In STEAL policy, uncommitted data are allowed to overwrite committed data. In the policy, if the transaction that performed updates abort or the system crashes before all uncommitted data are committed, we will need some way of restoring the uncommitted, affected files to how they were before in order to enforce atomicity (need of UNDO). In NO FORCE policy, commited pages do not need to be written to the disk before commit. In the policy, if the system crashes before the commit pages are written to the disk, then we need some way of redoing actions to the pages (so to the disk) in order to enforce durability. In order to support REDOing and UNDOing, we need some sort of logging system (WAL, etc). Since we simply implemented NO STEAL/FORCE, we didn't have to deal with logging (which is much more complicated to implement than what we did for the project).
If our system could crash while running transacitonComplete, then the system could crash after we committed some but not all of the transaction's changes. Then, we have no way of knowing which dirty pages were committed. Hence, we will need some logging system to keep track of which dirty pages were affected. Then, our program could UNDO everything and notify user of failed commit.

What ACID properties do these simplifications above aim to guarantee?
3) NO STEAL/FORCE implementation helps ensure atomicity and durability because STEAL/NO FORCE makes it complicated to support atomicity and durability (disscussed in 2). If we assume that system won't crash while running transactionComplete, atomicity is guaranteeed because if system crashes during transactionComplete, then we can be left in an intermediate state in which commit is only partially done.

Discuss and justify any changes you made to the API.
4) We did not make any API change.
